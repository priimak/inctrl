{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"InCtrl - Instruments Control Python API","text":"<p>InCtrl library provides high level API to common electronics bench instruments, such programmable power supplies, electronic loads, oscilloscopes and many more. Its intent is twofold. Provide API at such high level so as to minimize cognitive load on electrical and application engineers working and the lab making lab automation easy. And second, make it possible to write code that would use InCtrl library to be agnostic to instruments makes and model where possible, i.e. application engineers should be able to swap one equipment make for another and have their python scripts continue running without any change. To that end interation with the instruments happens using generic handlers to instrument types. For example, to interact with power supply user need to create an instance of <code>PowerSupply</code> class like so</p> <pre><code>from inctrl import power_supply, PowerSupply\n\nps: PowerSupply = power_supply(\"$ps_address\", channel = 1)\n</code></pre> <p>Function <code>power_supply(...)</code> when called will discover make and mode of a particular power supply and return appropriate instance of <code>PowerSupply</code>. That could be <code>RigolPowerSupply</code>, <code>KikusuiPowerSupply</code> or what have you. User does not have to be concerned with make and model that power supply. This is of course true only up to a point. For example, you may need power supply that can supply 100 Watts and swapping one for another might not even though API would stay the same. To resolve this issue user can request specific capabilities that instantiating power supply my have. Details of that can be found in other pages.</p>"},{"location":"name_resolution/","title":"Instrument name and parameters resolution","text":""},{"location":"oscilloscope/","title":"Oscilloscope","text":""},{"location":"oscilloscope/#instantiation","title":"Instantiation","text":"<p>Oscilloscope class is instantiated like so</p> <pre><code>from inctrl import oscilloscope, Oscilloscope\n\nscope: Oscilloscope = oscilloscope(\"$address\")\n</code></pre> <p>Address argument allows to access a particular oscilloscope connected to your computer or present on the network. This address string could be a VISA address or an alias. In the case of alias actual address (and some other parameters) has to be resolved by some means. Details of that are in the \"Instrument name and parameters resolution\" page.</p> <p>Returned object (assigned to the variable <code>scope</code>) is an instance of <code>Oscilloscope</code> class. Which instance, will depend on identification of the scope or can be forced though name and parameter resolution.</p> <p>To ensure that oscilloscope to which you are connecting has required properties you can also pass <code>capability</code> argument. For example, let say you require scope to have 8 channels. You can do it like so:</p> <pre><code>scope: Oscilloscope = oscilloscope(\n    \"$address\", capabilities = {\"num_channels\": 8}\n)\n</code></pre> <p>Another way to ensure that you got instrument and a class that you want is to call <code>scope.as_class(...)</code> method. For example if you want to ensure that you are working with LeCroy scope you do following.</p> <pre><code>from inctrl.drivers.oscilloscope import LeCroyOscilloscope\n\nscope: LeCroyOscilloscope = oscilloscope(\"$address\").as_class(LeCroyOscilloscope)\n</code></pre> <p>If oscilloscope that you are connecting here is not a LeCroy scope then calling <code>as_class(LeCroyOscilloscope)</code> will raise RuntimeError. This way you can ensure you connect to a specific make of the oscilloscope and obtain access to methods unique to that particual scope.</p>"},{"location":"oscilloscope/#capabilities","title":"Capabilities","text":"<p>TBD</p>"},{"location":"oscilloscope/#interacting-with-the-scope","title":"Interacting with the scope","text":"<p>An oscilloscope has several logical components, primary being (1) the scope itself as a whole, (2) channels and (3) a trigger.</p>"},{"location":"oscilloscope/#scope-as-a-whole","title":"Scope as a whole","text":"<p>At this level you can set time window for scope capture like so:</p> <pre><code>from inctrl.model import Duration\n\ntime_window: Duration = scope.set_time_window(\"22 us\")\n</code></pre> <p>Argument to this function is a string containing time interval in the human-readable form or an instance of class <code>Duration</code>. Since often not every time interval can be set, this function returns actually set duration for the capture window. However, we guarantee that actually set time window will always be greater or equal to the requested value and never less.</p> <p>Alternatively you can set duration per time division, also known as time scale</p> <pre><code>from inctrl.model import Duration\n\ntime_per_div: Duration = scope.set_time_scale(\"5 us\")\n</code></pre> <p>Similarly to <code>set_time_window(...)</code> function <code>set_time_scale(...)</code> also returns actually set value.</p> <p>Configured values can also be retrieved by calling <code>scope.get_time_window()</code> and <code>scope.get_time_scale()</code>.</p>"},{"location":"oscilloscope/#channel","title":"Channel","text":"<p>To obtain handles to a given scope channel you can call <code>scope.channel(...)</code> function. This function accepts either channel number of channel name. In the later case channel name has to be defined through mechanisms described in \"Instrument name and parameters resolution\" page.</p> <pre><code>ch3 = scope.channel(3)\nclk = scope.channel(\"CLK\")\n</code></pre> <p>Using these variables you can now adjust various properties associated with this channel.</p>"},{"location":"oscilloscope/#coupling","title":"Coupling","text":"<p>Channel coupling can by set by calling <code>set_coupling(coupling: ChannelCoupling, fail_on_error: bool = False)</code> method.</p> <pre><code>from inctrl import ChannelCoupling\n\nch3.set_coupling(ChannelCoupling.AC)\n</code></pre> <p>Not every kind of coupling might be supported on the scope. Possible coupling constants are AC, DC and GND. If <code>fail_on_error</code> argument is set to False (default), then simply return configured coupling even if unable to set requested coupling type. If If <code>fail_on_error</code> is True and fail to set requested coupling, then raise <code>RuntimeError</code>.</p> <p>Use companion function <code>channel.get_coupling()</code> to obtain currently configured coupling on the channel.</p>"},{"location":"oscilloscope/#vertical-scaling-and-offset","title":"Vertical scaling and offset","text":"<p>To ensure that signal you are trying to capture does not clip you can call function <code>set_range(...)</code>. This function is provided as an alternative to setting voltage per division and offset.</p> <pre><code>ch3_Vmin, ch3_Vmax = ch3.set_range_V(-1, 10)\n</code></pre> <p>This function guaranteed to set voltage per division and vertical offset such that requested voltage range fits on the screen. It returns a tuple of actually set min and max values. These will usually match with voltage range and scope screen. Voltage range as configured on the scope can always be retrieved by calling <code>get_range_V()</code>.</p> <pre><code>ch3_Vmin, ch3_Vmax = ch3.get_range_V()\n</code></pre> <p>Alternatively you can call lower level functions <code>ch.set_offset_V(...)</code> and <code>ch.scale_V(...)</code> (both return actually set values) and their companions <code>ch.get_offset_V()</code> and <code>ch.get_scale_V()</code>.</p> <pre><code>ch3_offset_V = ch3.set_offset_V(0.0023)\nch3_V_per_div = ch3.get_scale_V(0.008)\n</code></pre>"},{"location":"oscilloscope/#impedance","title":"Impedance","text":"<p>Channel input impedance can be set by calling function <code>set_impedance_oHm(impedance_oHm: float, fail_on_error: bool = False) -&gt; float</code>. Different oscilloscopes offer different impedance values that can be set. Typically, that is 50 Ohm and 1 MOhm. Calling this function like so is guaranteed to return actually set impedance value.</p> <pre><code>ch3_impedance = ch3.set_impedance_oHm(100)\n</code></pre> <p>The above call might behave differently depending on the scope make and model. It might set impedance to the nearest allowed value or simply reject it keeping whatever configured intact. Users can use returned value to decide what do to about it. Alternatively call like so will ensure that requested impedance is set or error raised.</p> <pre><code>ch3.set_impedance_oHm(50, fail_on_error = True)\n</code></pre> <p>List of allowed impedance values can be obtained from the <code>scope.properties</code> namespace like so</p> <pre><code>allowed_impedance_values: list[float] = scope.properties.get_impedance_list()\n</code></pre> <p>Alternative to above calls is to call functions</p> <pre><code>ch3_impedance = ch3.set_impedance_min()\n</code></pre> <p>or</p> <pre><code>ch3_impedance = ch3.set_impedance_max()\n</code></pre> <p>which set minimum and maximum impedance value valid on a particular scope.</p>"},{"location":"oscilloscope/#downloading-waveform","title":"Downloading waveform","text":"<p>When tigger (see below) is congured and enabled on the scope, then waveform can be captured and downloaded as a <code>Waveform</code> class like so:</p> <pre><code>c1_waveform: Waveform = ch3.get_waveform()\n</code></pre> <p>To ensure that you download valid waveform call <code>scope.trigger.wait_for_waveform(...)</code> method (see below).</p>"},{"location":"oscilloscope/#trigger","title":"Trigger","text":"<p>Interaction with triggers consist of two parts: (a) configuring the trigger and (2) interacting with configured trigger. All of this is available under <code>scope.trigger</code> namespace.</p>"},{"location":"oscilloscope/#configuration","title":"Configuration","text":"<p>To configure trigger call function <code>scope.trigger.configure(trigger: ScopeTrigger) -&gt; None</code>. Argument passed to this function is an instance of <code>ScopeTrigger</code> class corresponding to a particular trigger type. At minimum, every oscilloscope offers edge trigger where signal capture happens on either raising or falling edge of signal. Other triggers can trigger signal capture on pulse evens, signal patterns and so on. At the moment we only provide code for triggering on the signal edges.</p> <p>Below is a minimal edge trigger configuration, which configures scope to trigger capture on the raising edge of signal <code>ch3</code> (that is known as trigger source) when it crosses 0.5 volts level.</p> <pre><code>from inctrl import ScopeTrigger\n\nscope.trigger.configure(ScopeTrigger.EDGE(trigger_source = ch3, level_V = 0.5))\n</code></pre> <p>Method <code>ScopeTrigger.EDGE(...)</code> has the following signature:</p> <pre><code>def EDGE(\n        trigger_source: TriggerSource,\n        level_V: float,\n        slope: TriggerSlope = TriggerSlope.RISING,\n        delay: str | Duration = Duration.value_of(\"0 s\")\n) -&gt; ScopeEdgeTrigger:\n</code></pre> <p>As you can see default <code>slope</code> is <code>TriggerSlope.RISING</code> but you can change to <code>TriggerSlope.FALLING</code>. Parameter <code>delay</code> refer to position on the screen when trigger is fired. Default value of 0 seconds places trigger position in the middle of the screen, i.e. there is a same duration of captured signal before and after trigger. Setting delay to negative value moves trigger position to the left, i.e. there is more data points captured after the trigger than before. Setting delay to positive value moves trigger position to the right, i.e. there is fewer data points captured after the trigger than before.</p>"},{"location":"oscilloscope/#operations","title":"Operations","text":"<p>Once trigger is configured you can arm the trigger to enable it. You can think of this as trigger modes.</p> <p>For a single shot capture call</p> <pre><code>scope.trigger.arm_single()\n</code></pre> <p>This function is non-blocking and it might time a bit of time until trigger is actually armed. To check if trigger is armed call</p> <pre><code>is_armed: bool = scope.trigger.is_armed()\n</code></pre> <p>To manually disarm trigger call</p> <pre><code>scope.trigger.disarm()\n</code></pre> <p>For continuous periodic capture call</p> <pre><code>scope.trigger.arm_auto()\n</code></pre> <p>For normal capture</p> <pre><code>scope.trigger.arm_normal()\n</code></pre> <p>Once trigger is fired and waveforms are available they can be downloaded from the scope. To check if waveforms are available call</p> <pre><code>scope.trigger.wait_for_waveform()\n</code></pre> <p>Call like above will block indefinitely until trigger is fired and waveform is available for downloading. Other optional arguments to this function can modify this behaviour. Signature for this function is</p> <pre><code>def wait_for_waveform(\n        timeout: str | Duration | None = None,\n        error_on_timeout: bool = False\n) -&gt; bool\n</code></pre> <p>If <code>timeout</code> is not provided, then block wait indefinitely. If <code>timeout</code> is provided, then wait for that duration and (if <code>error_on_timeout</code> is False (default)) return True or False if waveform is actually available for downloading, or, if <code>error_on_timeout</code> is True, then raise RuntimeError after requested duration or return True on success.</p>"},{"location":"oscilloscope/#examples","title":"Examples","text":""},{"location":"oscilloscope/#capturing-i2c-data","title":"Capturing I2C data","text":"<pre><code>from inctrl import ScopeTrigger, oscilloscope, TriggerSlope\n\n# Obtain handle to the connected oscilloscope\nscope = oscilloscope(\"$address\")\n\n# We want to capture a 20 us waveform, hence we set time window \n# to a bit larger value\nscope.set_time_window(\"23 us\")\n\n# Channel 1 refers to SCL (system clock) line\nscl = scope.channel(1)\nscl.set_impedance_max()\n\n# Channel 1 refers to SDC (data) line\nsdc = scope.channel(2)\nsdc.set_impedance_max()\n\n# Signals will be from 0 to 3.3 V. Setting range from -0.2 to 4 volts\n# will ensure that all data is captured including noise.\nscl.set_range_V(-0.2, 4)\nsdc.set_range_V(-0.2, 4)\n\nscope.trigger.configure(ScopeTrigger.EDGE(\n    # trigger on voltage change in data line\n    trigger_source = sdc,\n\n    # trigger when voltage crosses 1.6 volt on the way down\n    # to 0 from 3.3 volts\n    level_V = 1.6,\n\n    # we are interested in mosty what happens after the trigger point\n    delay = \"-20 us\",\n\n    # capture on the falling edge as by default signal is pulled up\n    slope = TriggerSlope.FALLING\n))\n\n# arm trigger, download waveforms and save them to files.\nscope.trigger.arm_single()\nscope.trigger.wait_for_waveform(\"10 s\", error_on_timeout = True)\ncsl_waveform = scl.get_waveform()\nsdc_waveform = sdc.get_waveform()\ncsl_waveform.save_to_file(\"csl.wfm\")\nsdc_waveform.save_to_file(\"sdc.wfm\")\n</code></pre>"},{"location":"waveform/","title":"Waveform","text":""}]}