{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"InCtrl - Instruments Control Python API","text":"<p>InCtrl library provides high level API to common electronics bench instruments, such programmable power supplies, electronic loads, oscilloscopes and many more. Its intent is twofold. Provide API at such high level so as to minimize cognitive load on electrical and application engineers working and the lab making lab automation easy. And second, make it possible to write code that would use InCtrl library to be agnostic to instruments makes and model where possible, i.e. application engineers should be able to swap one equipment make for another and have their python scripts continue running without any change. To that end interation with the instruments happens using generic handlers to instrument types. For example, to interact with power supply user need to create an instance of <code>PowerSupply</code> class like so</p> <pre><code>from inctrl import power_supply, PowerSupply\n\nps: PowerSupply = power_supply(\"$ps_address\", channel = 1)\n</code></pre> <p>Function <code>power_supply(...)</code> when called will discover make and mode of a particular power supply and return appropriate instance of <code>PowerSupply</code>. That could be <code>RigolPowerSupply</code>, <code>KikusuiPowerSupply</code> or what have you. User does not have to be concerned with make and model that power supply. This is of course true only up to a point. For example, you may need power supply that can supply 100 Watts and swapping one for another might not even though API would stay the same. To resolve this issue user can request specific capabilities that instantiating power supply my have. Details of that can be found in other pages.</p> <p>InCtrl is written in pure python and distributed under MIT license. Its source code can be found at https://github.com/priimak/inctrl.</p>"},{"location":"duration/","title":"Duration","text":"<p>Class <code>Duration</code> is used internally in the <code>InCtrl</code> library but can also be used by the user.</p>"},{"location":"name_resolution/","title":"Instrument name and parameters resolution","text":""},{"location":"oscilloscope/","title":"Oscilloscope","text":""},{"location":"oscilloscope/#instantiation","title":"Instantiation","text":"<p>Oscilloscope class is instantiated like so</p> <pre><code>from inctrl import oscilloscope, Oscilloscope\n\nscope: Oscilloscope = oscilloscope(\"$address\")\n</code></pre> <p>Address argument allows to access a particular oscilloscope connected to your computer or present on the network. This address string could be a VISA address or an alias. In the case of alias actual address (and some other parameters) has to be resolved by some means. Details of that are in the \"Instrument name and parameters resolution\" page.</p> <p>Returned object (assigned to the variable <code>scope</code>) is an instance of <code>Oscilloscope</code> class. Which instance, will depend on identification of the scope or can be forced though name and parameter resolution.</p> <p>To ensure that oscilloscope to which you are connecting has required properties you can also pass <code>capability</code> argument. For example, let say you require scope to have 8 channels. You can do it like so:</p> <pre><code>scope: Oscilloscope = oscilloscope(\n    \"$address\", capabilities = {\"num_channels\": 8}\n)\n</code></pre> <p>Another way to ensure that you got instrument and a class that you want is to call <code>scope.as_class(...)</code> method. For example if you want to ensure that you are working with LeCroy scope you do following.</p> <pre><code>from inctrl.drivers.oscilloscope import LeCroyOscilloscope\n\nscope: LeCroyOscilloscope = oscilloscope(\"$address\").as_class(LeCroyOscilloscope)\n</code></pre> <p>If oscilloscope that you are connecting here is not a LeCroy scope then calling <code>as_class(LeCroyOscilloscope)</code> will raise RuntimeError. This way you can ensure you connect to a specific make of the oscilloscope and obtain access to methods unique to that particual scope.</p>"},{"location":"oscilloscope/#capabilities","title":"Capabilities","text":"<p>TBD</p>"},{"location":"oscilloscope/#interacting-with-the-scope","title":"Interacting with the scope","text":"<p>An oscilloscope has several logical components, primary being (1) the scope itself as a whole, (2) channels and (3) a trigger.</p>"},{"location":"oscilloscope/#scope-as-a-whole","title":"Scope as a whole","text":"<p>At this level you can set time window for scope capture like so:</p> <pre><code>from inctrl.model import Duration\n\ntime_window: Duration = scope.set_time_window(\"22 us\")\n</code></pre> <p>Argument to this function is a string containing time interval in the human-readable form or an instance of class <code>Duration</code>. Since often not every time interval can be set, this function returns actually set duration for the capture window. However, we guarantee that actually set time window will always be greater or equal to the requested value and never less.</p> <p>Alternatively you can set duration per time division, also known as time scale</p> <pre><code>from inctrl.model import Duration\n\ntime_per_div: Duration = scope.set_time_scale(\"5 us\")\n</code></pre> <p>Similarly to <code>set_time_window(...)</code> function <code>set_time_scale(...)</code> also returns actually set value.</p> <p>Configured values can also be retrieved by calling <code>scope.get_time_window()</code> and <code>scope.get_time_scale()</code>.</p>"},{"location":"oscilloscope/#channel","title":"Channel","text":"<p>To obtain handles to a given scope channel you can call <code>scope.channel(...)</code> function. This function accepts either channel number of channel name. In the later case channel name has to be defined through mechanisms described in \"Instrument name and parameters resolution\" page.</p> <pre><code>ch3 = scope.channel(3)\nclk = scope.channel(\"CLK\")\n</code></pre> <p>Using these variables you can now interact with this channel and adjust various properties associated it.</p>"},{"location":"oscilloscope/#coupling","title":"Coupling","text":"<p>Channel coupling can by set by calling <code>set_coupling(coupling: ChannelCoupling, fail_on_error: bool = False)</code> method.</p> <pre><code>from inctrl import ChannelCoupling\n\nch3.set_coupling(ChannelCoupling.AC)\n</code></pre> <p>Not every kind of coupling might be supported on the scope. Possible coupling constants are AC, DC and GND. If <code>fail_on_error</code> argument is set to False (default), then simply return configured coupling even if unable to set requested coupling type. If If <code>fail_on_error</code> is True and fail to set requested coupling, then raise <code>RuntimeError</code>.</p> <p>Use companion function <code>channel.get_coupling()</code> to obtain currently configured coupling on the channel.</p>"},{"location":"oscilloscope/#vertical-scaling-and-offset","title":"Vertical scaling and offset","text":"<p>To ensure that signal you are trying to capture does not clip you can call function <code>set_range(...)</code>. This function is provided as an alternative to setting voltage per division and offset.</p> <pre><code>ch3_Vmin, ch3_Vmax = ch3.set_range_V(-1, 10)\n</code></pre> <p>This function guaranteed to set voltage per division and vertical offset such that requested voltage range fits on the screen. It returns a tuple of actually set min and max values. These will usually match with voltage range and scope screen. Voltage range as configured on the scope can always be retrieved by calling <code>get_range_V()</code>.</p> <pre><code>ch3_Vmin, ch3_Vmax = ch3.get_range_V()\n</code></pre> <p>Alternatively you can call lower level functions <code>ch.set_offset_V(...)</code> and <code>ch.scale_V(...)</code> (both return actually set values) and their companions <code>ch.get_offset_V()</code> and <code>ch.get_scale_V()</code>.</p> <pre><code>ch3_offset_V = ch3.set_offset_V(0.0023)\nch3_V_per_div = ch3.get_scale_V(0.008)\n</code></pre>"},{"location":"oscilloscope/#impedance","title":"Impedance","text":"<p>Channel input impedance can be set by calling function <code>set_impedance_oHm(impedance_oHm: float, fail_on_error: bool = False) -&gt; float</code>. Different oscilloscopes offer different impedance values that can be set. Typically, that is 50 Ohm and 1 MOhm. Calling this function like so is guaranteed to return actually set impedance value.</p> <pre><code>ch3_impedance = ch3.set_impedance_oHm(100)\n</code></pre> <p>The above call might behave differently depending on the scope make and model. It might set impedance to the nearest allowed value or simply reject it keeping whatever configured intact. Users can use returned value to decide what do to about it. Alternatively call like so will ensure that requested impedance is set or error raised.</p> <pre><code>ch3.set_impedance_oHm(50, fail_on_error = True)\n</code></pre> <p>List of allowed impedance values can be obtained from the <code>scope.properties</code> namespace like so</p> <pre><code>allowed_impedance_values: list[float] = scope.properties.get_impedance_list()\n</code></pre> <p>Alternative to above calls is to call functions</p> <pre><code>ch3_impedance = ch3.set_impedance_min()\n</code></pre> <p>or</p> <pre><code>ch3_impedance = ch3.set_impedance_max()\n</code></pre> <p>which set minimum and maximum impedance value valid on a particular scope.</p>"},{"location":"oscilloscope/#downloading-waveform","title":"Downloading waveform","text":"<p>When tigger (see below) is configured and enabled on the scope, then waveform can be captured and downloaded as a <code>Waveform</code> class like so:</p> <pre><code>c1_waveform: Waveform = ch3.get_waveform()\n</code></pre> <p>Returned object (instance of <code>Waveform</code> class) will have various metadata mostly related to how it is to be rendered. Among this metadata Waveform will have name. By default, name given to the waveform will be name of the channel if channel does have a name. If channel does not have a name, but is simply referred to by a number, then waveform name will be \"Channel $channel_number\".</p> <p>To give waveform a custom name you can either call <code>get_waveform($name)</code> with <code>name</code> argument</p> <pre><code>mosi_waveform: Waveform = ch3.get_waveform(\"mosi\")\n</code></pre> <p>or set name on the already obtained waveform object</p> <pre><code>from inctrl import Waveform\n\nc1_waveform: Waveform = ch3.get_waveform()\nc1_waveform.name = \"mosi\"\n</code></pre> <p>To ensure that you download valid waveform call <code>scope.trigger.wait_for_waveform(...)</code> method (see below).</p>"},{"location":"oscilloscope/#trigger","title":"Trigger","text":"<p>Interaction with triggers consist of two parts: (a) configuring the trigger and (2) interacting with configured trigger. All of this is available under <code>scope.trigger</code> namespace.</p>"},{"location":"oscilloscope/#configuration","title":"Configuration","text":"<p>To configure trigger call function <code>scope.trigger.configure(trigger: ScopeTrigger) -&gt; None</code>. Argument passed to this function is an instance of <code>ScopeTrigger</code> class corresponding to a particular trigger type. At minimum, every oscilloscope offers edge trigger where signal capture happens on either raising or falling edge of signal. Other triggers can trigger signal capture on pulse evens, signal patterns and so on. At the moment we only provide code for triggering on the signal edges.</p> <p>Below is a minimal edge trigger configuration, which configures scope to trigger capture on the raising edge of signal <code>ch3</code> (that is known as trigger source) when it crosses 0.5 volts level.</p> <pre><code>from inctrl import ScopeTrigger\n\nscope.trigger.configure(ScopeTrigger.EDGE(trigger_source = ch3, level_V = 0.5))\n</code></pre> <p>Method <code>ScopeTrigger.EDGE(...)</code> has the following signature:</p> <pre><code>def EDGE(\n        trigger_source: TriggerSource,\n        level_V: float,\n        slope: TriggerSlope = TriggerSlope.RISING,\n        delay: str | Duration = Duration.value_of(\"0 s\")\n) -&gt; ScopeEdgeTrigger:\n</code></pre> <p>As you can see default <code>slope</code> is <code>TriggerSlope.RISING</code> but you can change to <code>TriggerSlope.FALLING</code>. Parameter <code>delay</code> refer to position on the screen when trigger is fired. Default value of 0 seconds places trigger position in the middle of the screen, i.e. there is a same duration of captured signal before and after trigger. Setting delay to positive value moves trigger position to the left, i.e. there is more data points captured after the trigger than before. Setting delay to negative value moves trigger position to the right, i.e. there is fewer data points captured after the trigger than before.</p>"},{"location":"oscilloscope/#operations","title":"Operations","text":"<p>Once trigger is configured you can arm the trigger to enable it. You can think of this as trigger modes.</p> <p>For a single shot capture call</p> <pre><code>scope.trigger.arm_single()\n</code></pre> <p>This function is non-blocking and it might time a bit of time until trigger is actually armed. To check if trigger is armed call</p> <pre><code>is_armed: bool = scope.trigger.is_armed()\n</code></pre> <p>To manually disarm trigger call</p> <pre><code>scope.trigger.disarm()\n</code></pre> <p>For continuous periodic capture call</p> <pre><code>scope.trigger.arm_auto()\n</code></pre> <p>For normal capture</p> <pre><code>scope.trigger.arm_normal()\n</code></pre> <p>Once trigger is fired and waveforms are available they can be downloaded from the scope. To check if waveforms are available call</p> <pre><code>scope.trigger.wait_for_waveform()\n</code></pre> <p>Call like above will block indefinitely until trigger is fired and waveform is available for downloading. Other optional arguments to this function can modify this behaviour. Signature for this function is</p> <pre><code>def wait_for_waveform(\n        timeout: str | Duration | None = None,\n        error_on_timeout: bool = False\n) -&gt; bool\n</code></pre> <p>If <code>timeout</code> is not provided, then block wait indefinitely. If <code>timeout</code> is provided, then wait for that duration and (if <code>error_on_timeout</code> is False (default)) return True or False if waveform is actually available for downloading, or, if <code>error_on_timeout</code> is True, then raise RuntimeError after requested duration or return True on success.</p>"},{"location":"oscilloscope/#examples","title":"Examples","text":""},{"location":"oscilloscope/#capturing-i2c-data","title":"Capturing I2C data","text":"<pre><code>from inctrl import ScopeTrigger, oscilloscope, TriggerSlope\n\n# Obtain handle to the connected oscilloscope\nscope = oscilloscope(\"$address\")\n\n# We want to capture a 20 us waveform, hence we set time window \n# to a bit larger value\nscope.set_time_window(\"23 us\")\n\n# Channel 1 refers to SCL (system clock) line\nscl = scope.channel(1)\nscl.set_impedance_max()\n\n# Channel 1 refers to SDC (data) line\nsdc = scope.channel(2)\nsdc.set_impedance_max()\n\n# Signals will be from 0 to 3.3 V. Setting range from -0.2 to 4 volts\n# will ensure that all data is captured including noise.\nscl.set_range_V(-0.2, 4)\nsdc.set_range_V(-0.2, 4)\n\nscope.trigger.configure(ScopeTrigger.EDGE(\n    # trigger on voltage change in data line\n    trigger_source = sdc,\n\n    # trigger when voltage crosses 1.6 volt on the way down\n    # to 0 from 3.3 volts\n    level_V = 1.6,\n\n    # we are interested in mosty what happens after the trigger point\n    delay = \"20 us\",\n\n    # capture on the falling edge as by default signal is pulled up\n    slope = TriggerSlope.FALLING\n))\n\n# arm trigger, download waveforms and save them to files.\nscope.trigger.arm_single()\nscope.trigger.wait_for_waveform(\"10 s\", error_on_timeout = True)\ncsl_waveform = scl.get_waveform()\nsdc_waveform = sdc.get_waveform()\ncsl_waveform.save_to_file(\"csl.wfm\")\nsdc_waveform.save_to_file(\"sdc.wfm\")\n</code></pre>"},{"location":"supported_instruments/","title":"Supported Instruments","text":"<p>Below is a table indicating which instruments does InCtrl library supports. There are two important things to note. First of allthat drivers are developed based on the documentation which usually applies to the whole family of instruments and hence it is implied that all instruments in that family are supported. That is expressed as regex expression in the \"Supported models\" column. At the same time drivers are tested on the very particular instrument model (that is in the \"Tested on model\" column). Hence, ultimately we can guarantee support only for those instruments that were tested against.</p> <p>Also, important to note that supported means that all the API calls/functions are supported. That does not mean that all functionality available on the given instrument is exposed through this API. 100% support refers to support of what is only defined in the InCtrl API.</p> Type Make Tested on model Supported models Oscilloscope Siglent SDS804X HD ^SDS8.*$"},{"location":"waveform/","title":"Waveform","text":"<p>When using oscilloscope you can download waveform for any given channel by calling <code>channel.get_waveform()</code> method. On this page we will outline what you can do with the waveform object.</p>"},{"location":"waveform/#accessing-x-y-values","title":"Accessing x-y values","text":"<p>Functions <code>Waveform::x(...)</code>, <code>Waveform::x(...)</code> and <code>Waveform::xy(...)</code> are used to access x-y values of the waveform. Function <code>xy(...)</code> is a superset of the other two. Hence, we will talk just about this function. The same concepts will be applicable to the <code>x(...)</code> and <code>y(...)</code> functions.</p> <p>By default, simply calling <code>waveform.xy()</code> return tuple of numpy ndarrays for the whole of the trace. First one holding x-axis values in unit of seconds and second y-axis values (usually that is voltage).</p> <pre><code>ts, ys = waveform.xy()\n</code></pre> <p>You can request different time units on the x-axis. For example in microseconds:</p> <pre><code>ts, ys = waveform.xy(\"us\")\n</code></pre> <p>or</p> <pre><code>from inctrl import TimeUnit\n\nts, ys = waveform.xy(TimeUnit.US)\n</code></pre> <p>You can indicate time unit as either a string using usual unit notation (<code>\"s\"</code> for seconds, <code>\"ms\"</code> for milliseconds and so on) or pass <code>TimeUnit</code> enum value.</p> <p>Time 0 corresponds to the moment of when trigger is fired. To see part of the waveform after the trigger you can pass <code>x_predicate</code> filter argument like so:</p> <pre><code>ts, ys = waveform.xy(x_predicate = lambda t: t &gt;= 0)\n</code></pre> <p>Note that <code>x_predicate</code> function will always receive time in seconds, independently of the requested time unit. Thus following two calls return the same arrays.</p> <pre><code>ts, ys = waveform.xy(time_unit = TimeUnit.US, x_predicate = lambda t: t &gt;= 0.003)\n\nts, ys = waveform.xy(time_unit = TimeUnit.MS, x_predicate = lambda t: t &gt;= 0.003)\n</code></pre>"},{"location":"waveform/#math-operations","title":"Math operations","text":""},{"location":"waveform/#scaling","title":"Scaling","text":"<p>Waveform can be multiplied or divided by a number producing new scaled waveform. For example:</p> <pre><code>w2 = waveform * 2\n\nw_half = waveform / 2\n</code></pre>"},{"location":"waveform/#add-subtract-multiply","title":"Add, subtract, multiply","text":"<p>Two waveforms that have exactly the same values on the x-axis can be added, subtracted or multiplied.</p> <pre><code>waveform1 * waveform2\n</code></pre>"},{"location":"waveform/#changing-waveform-metadata","title":"Changing waveform metadata","text":"<p>Some of the waveform metadata can be changed. In particular waveform has a name derived from either a channel name or when waveform if obtained by calling <code>channel.get_waveform(name = \"$name\")</code>. This name is used for plotting waveform.</p> <p>You can change it like so</p> <pre><code>waveform.name = \"Vout\"\n</code></pre>"},{"location":"waveform/#saving-into-a-file","title":"Saving into a file","text":"<p>Waveform can be saved into a file together with all of its metadata like so</p> <pre><code>waveform.save_to_file(\"waveform.wfm\")\n</code></pre> <p>This will save it in compact binary form using parquet data format.</p> <p>It can then be loaded like so</p> <pre><code>waveform = Waveform.load_from_file(\"waveform.wfm\")\n</code></pre>"},{"location":"waveform/#exporting-into-csv","title":"Exporting into csv","text":"<p>X and Y values for a waveform can be exported into a csv file like so</p> <pre><code>waveform.export_to_csv_file(\"waveform.csv\")\n</code></pre> <p>In this format no metadata will be stored in the resulting file, online time and voltage values. By default, resulting csv file will include a header (first row) identifying column names, these will be strings <code>\"t\"</code> and <code>\"y\"</code>. This header can be excluded like so</p> <pre><code>waveform.export_to_csv_file(\"waveform.csv\", include_column_names = False)\n</code></pre> <p>Time column will be in seconds but can overridden like so</p> <pre><code>waveform.export_to_csv_file(\"waveform.csv\", time_unit = \"us\", include_column_names = False)\n</code></pre> <p>or</p> <pre><code>waveform.export_to_csv_file(\"waveform.csv\", time_unit = TimeUnit.US, include_column_names = False)\n</code></pre>"},{"location":"waveform/#plotting","title":"Plotting","text":"<p>If optional matplotlib library is installed then waveform can be plotted and shown in GUI window like so</p> <pre><code>waveform.plot()\n</code></pre> <p>This call will block until plot window is closed, unless optional <code>block</code> argument is set to <code>False</code></p> <pre><code>waveform.plot(block = False)\n</code></pre> <p>By default, time unit on the x-axis will be set automatically to provide most compact representation for time values. It can, however, be overridden like so:</p> <pre><code>waveform.plot(time_unit = \"ms\")\n\nwaveform.plot(time_unit = TimeUnit.MS)\n</code></pre> <p>To generate image png file, pass <code>to_file</code> argument like so</p> <pre><code>waveform.plot(to_file = \"waveform.png\")\n</code></pre> <p>When called like so this call never blocks independently value assigned to <code>block</code> argument.</p> <p>Writing into png file will use default DPI (dots per inch) value as set in matplotlib, but can be overridden by supplying <code>dpi</code> argument like so:</p> <pre><code>waveform.plot(to_file = \"waveform.png\", dpi = 600)\n</code></pre> <p>Note, that DPI value will affect image size.</p>"}]}